import{_ as e,a as t,o as a,a5 as r}from"./chunks/framework.DupWrZfa.js";const T=JSON.parse('{"title":"What is Tree-Conver?","description":"","frontmatter":{},"headers":[],"relativePath":"en/Introducton/1.What is TreeConver.md","filePath":"en/Introducton/1.What is TreeConver.md","lastUpdated":1710060437000}'),o={name:"en/Introducton/1.What is TreeConver.md"},n=r('<h1 id="what-is-tree-conver" tabindex="-1">What is Tree-Conver? <a class="header-anchor" href="#what-is-tree-conver" aria-label="Permalink to &quot;What is Tree-Conver?&quot;">​</a></h1><p>Tree-Conver is a tool that can convert between flat node arrays and tree arrays.</p><p>Exports two methods: <code>arrayToTree</code> and <code>treeToArray</code>.</p><h2 id="performance" tabindex="-1">Performance <a class="header-anchor" href="#performance" aria-label="Permalink to &quot;Performance&quot;">​</a></h2><h3 id="array-to-tree" tabindex="-1">Array to Tree <a class="header-anchor" href="#array-to-tree" aria-label="Permalink to &quot;Array to Tree&quot;">​</a></h3><p>This method has time and space complexity of O(n), where n is the length of the input array. The method traverses the array twice, once to create a mapping from node ID to node, and once to add nodes to their parent&#39;s children array. It ultimately stores all nodes and child nodes.</p><h3 id="tree-to-array" tabindex="-1">Tree to Array <a class="header-anchor" href="#tree-to-array" aria-label="Permalink to &quot;Tree to Array&quot;">​</a></h3><p>This method uses stack-based iteration, optimizing memory and call stack. The time complexity of this method depends on the depth and number of nodes in the tree. In the worst case, it is O(nlogn), but in the case of a shallow tree, it can maintain O(n) even with multiple child nodes.</p><p>The space complexity is O(n), where the maximum length of the node array in the stack is equal to the depth of the tree.</p>',9),s=[n];function i(h,d,c,l,m,p){return a(),t("div",null,s)}const f=e(o,[["render",i]]);export{T as __pageData,f as default};
