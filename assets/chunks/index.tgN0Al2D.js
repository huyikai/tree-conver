const g=(a,f={})=>{const{primaryKey:p="id",childrenKey:h="children",ignoreFields:r=[],addFields:n=[],needParentId:e=!0}=f,t=[],l=[];for(l.push({node:null,children:a,parentId:null});l.length;){const{node:i,children:c,parentId:u}=l.pop();if(i){const{[h]:o,...y}=i,s={...y};if(e&&(s.parentId=u),n.length)for(let d=0;d<n.length;d++)s[n[d].fieldName]=n[d].callback(i);if(r.length)for(let d=0;d<r.length;d++)delete s[r[d]];t.push(s)}if(c)for(let o=c.length-1;o>=0;o--)l.push({node:c[o],children:c[o][h]||[],parentId:(i==null?void 0:i[p])||""})}return t},I=(a,f={})=>{if(!Array.isArray(a))throw new Error("The first argument must be an array.");const{idKey:p="id",pidKey:h="pid",childrenKey:r="children"}=f,n=a.reduce((e,t)=>(e[t[p]]={...t,[r]:[]},e),{});return Object.values(n).forEach(e=>{const t=e[h];if(t){const l=n[t];l[r]||(l[r]=[]),l[r].push(e)}}),Object.values(n).filter(e=>!e[h])};export{g as e,I as r};
